Rust 的生命周期有初学者经常容易混淆的误区, 即 `T: 'static` 和 `&'static T` 的区别. 本文将详细介绍这两者的区别, 并举例说明.

每个 Rust 初学者在学习 hello world 的时候, 就会了解到 `let string = "hello world";` 中, `string` 的类型是 `&'static str`, 表明 `string` 对应的 `str` 会在整个程序的生命周期中存在. 然后学到线程时, 看到 `thread::spawn` 的函数签名长这样:
```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new().spawn(f).expect("failed to spawn thread")
}
```
其中闭包 `f` 的类型 `F` 限制为 `Send + 'static`, 就会误以为 `f` 必须拥有静态的生命周期, 也就是说 `f` 所捕获的变量必须存在于整个程序的生命周期. 如果真是这样, 那么 `thread::spawn` 的使用就会受到很大的限制, 无法捕获任何局部变量. 但实际上, `F: 'static` 并不是要求闭包 `f` 捕获的变量拥有静态的生命周期, 而是要求 `f` 捕获的变量能够安全地被 `f` 永久持有.