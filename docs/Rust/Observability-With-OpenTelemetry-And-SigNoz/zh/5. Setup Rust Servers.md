# 5. Setup Rust Servers

接下来需要完成 3 个 Rust 服务, 分别是 `storefront`, `pricing_engine`, `user_service`. 我只会展示核心代码. 以下代码可能略显枯燥, 因为包含了大量的 axum / tonic 样板代码. 如果你对这两个服务比较熟悉, 可以直接跳过, 只需要知道整体的链路是:

1. storefront 通过 /price?user_id=number&product_id=number 提供价格
2. storefront 调用 pricing_engine 获取价格
3. pricing_engine 并发调用 user_service 获取用户等级和折扣 + 调用自己内部逻辑获取商品原价

# main.proto (被 storefront 和 pricing_engine 共享)

```proto
syntax = "proto3";

package demo;

enum UserTier {
  BRONZE = 0;
  SILVER = 1;
  GOLD = 2;
}

service PricingService {
  rpc CalculatePrice(PriceRequest) returns (PriceResponse);
}

message PriceRequest {
  uint64 user_id = 1;
  uint64 product_id = 2;
}

message PriceResponse {
  uint64 product_id = 1;
  double original_price = 2;
  double discounted_price = 3;
  UserTier user_tier = 4;
}
```

# storefront

```rust
// price handler
#[derive(Debug, Deserialize)]
pub struct PriceQuery {
    pub user_id: u64,
    pub product_id: u64,
}

#[derive(Debug, Serialize)]
pub struct PriceResponse {
    pub price: f64,
}

impl IntoResponse for PriceResponse {
    fn into_response(self) -> axum::response::Response {
        (StatusCode::OK, serde_json::to_string(&self).unwrap()).into_response()
    }
}

#[instrument(skip(app_state))]
pub async fn price(
    State(mut app_state): State<AppState>,
    Query(query): Query<PriceQuery>,
) -> Result<PriceResponse, AppError> {
    let resp = &app_state // grpc 调用 pricing_engine 的方法
        .pricing_client
        .calculate_price(PriceRequest {
            user_id: query.user_id,
            product_id: query.product_id,
        })
        .await?;

    Ok(PriceResponse {
        price: resp.get_ref().discounted_price,
    })
}

use tonic::{transport::Channel};

#[derive(Clone, Debug)]
pub struct AppState {
    pricing_client: PricingServiceClient<Channel>, // PricingServiceClient 是 tonic_prost_build 生成的结构体
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 连接 tonic 服务, 也就是 pricing_engine. loop 直到 pricing_engine 启动成功
    let channel = loop {
        match Channel::from_static("http://localhost:50051") // 50051 是 pricing_engine 的端口
            .connect()
            .await
        {
            Ok(channel) => break channel,
            Err(e) => {
                println!("Failed due to {e}, retrying...");
                tokio::time::sleep(Duration::from_secs(1)).await;
            }
        }
    };

    let pricing_client = PricingServiceClient::new(channel);

    let app_state = AppState { pricing_client };

    let listener = tokio::net::TcpListener::bind("127.0.0.1:4040").await?;

    let app = axum::Router::new()
        .route("/price", get(price)))
        .with_state(app_state);

    info!("Storefront server running on http://localhost:4040");
    let res = axum::serve(listener, app).await;
    if let Err(e) = res {
        error!("Axum server error: {e}");
    }

    Ok(())
}
```

# pricing_engine

```rust
#[derive(Debug, Clone)]
pub struct ServerContext {
    pub user_client: UserClient, // 封装的 reqwest Client, 专门请求 user_service
}

impl ServerContext {
    pub fn new() -> Self {
        Self {
            user_client: UserClient::new("http://localhost:4041".to_string()), // 4041 是 user_service 的端口
        }
    }
}

pub struct PricingServiceImpl {
    ctx: ServerContext,
}

impl PricingServiceImpl {
    pub fn new(ctx: ServerContext) -> Self {
        Self { ctx }
    }
}

#[tonic::async_trait]
impl PricingService for PricingServiceImpl {
    #[instrument(skip_all, err)]
    async fn calculate_price(
        &self,
        request: Request<PriceRequest>,
    ) -> Result<Response<PriceResponse>, Status> {
        let req = request.into_inner();
        // 并发调用 user_service 和 get_product, 其中 get_product 是自己内部的调用
        let (user, product) = tokio::join!(
            self.ctx.user_client.get_user(req.user_id),
            get_product(req.product_id),
        );

        let user = user.map_err(|e| Status::internal(e.to_string()))?;
        let product = product.map_err(|e| Status::internal(e.to_string()))?;

        let price = product.price * user.discount_rate;

        Ok(Response::new(PriceResponse {
            product_id: req.product_id,
            original_price: product.price,
            user_tier: user.tier as i32,
            discounted_price: price,
        }))
    }
}

#[derive(Debug)]
struct ProductDetail {
    id: u64,
    price: f64,
    stock: u64,
}

#[instrument]
async fn get_product(product_id: u64) -> Result<ProductDetail, String> {
    tokio::time::sleep(Duration::from_secs(1)).await;

    Ok(ProductDetail {
        id: product_id,
        price: (product_id % 100) as f64,
        stock: 10,
    })
}


#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let ctx = ServerContext::new();
    let pricing_service = PricingServiceImpl::new(ctx);
    let pricing_service_server = PricingServiceServer::new(pricing_service);

    let grpc_server = Server::builder().add_service(pricing_service_server);

    info!("Pricing engine server running on http://localhost:50051");

    grpc_server.serve("127.0.0.1:50051".parse()?).await?;

    Ok(())
}

```

# user_service

```rust
#[instrument(skip_all)]
async fn get_user(Path(user_id): Path<u64>) -> Result<Json<GetUserResponse>, AppError> {
    if user_id == 0 {
        return Err(AppError::NotFound);
    }

    // 简单根据 user_id 判断等级
    let body = match user_id % 3 {
        0 => GetUserResponse {
            user_id,
            tier: 0, // 因为这是一个 http server, 所以用不了 proto 的 enum, 只能直接写数字
            discount_rate: 0.9,
        },
        1 => GetUserResponse {
            user_id,
            tier: 1,
            discount_rate: 0.7,
        },
        _ => GetUserResponse {
            user_id,
            tier: 2,
            discount_rate: 0.5,
        },
    };

    Ok(Json(body))
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:4041").await?;

    let app = axum::Router::new().route("/users/{id}", get(get_user));

    info!("User service running on http://localhost:4041");

    let res = axum::serve(listener, app).await;
    if let Err(e) = res {
        error!("Axum server error: {e}");
    }

    Ok(())
}
```

接下来同时启动三个服务, 然后使用 PostMan 之类的工具发一条请求:

```
GET http://localhost:4040/price?user_id=2&product_id=3467
```

会得到返回值:

```json
{ "price": 33.5 }
```

因为我们的逻辑是根据 user_id 为 2, 判断是 SILVER 用户, 折扣率为 0.7. 然后通过 product_id 3467 计算出原价是 67, 那么最终价格是 67 \* 0.7 = 33.5.
