# 1. Observability 简介

Observability (可观测性), 指的是观测一个程序在运行时的状态, 从而方便我们对程序进行监控, 调试, 以及故障排查.

可观测性一般分为三个维度:

1. Trace: 跟踪, 用于追踪程序的执行路径, 以及各个函数的调用关系. 举个例子, a 函数调用了 b 函数, 那么 trace a 就应该是 trace b 的 parent, 从可观测性平台里应该直观可以看到调用链路. 当一个服务返回 500 时, 就可以通过链路一步步排查错误源.

2. Log: 日志, 这个应该是大部分人最熟悉的部分, 打印程序运行时的状态, 以及错误信息.

3. Meter (metric): 指标, 用于统计程序的一些状态, 以及性能指标. 比如当前 CPU 占用率, 内存占用情况, 过去 1h 的 QPS, 500 的错误率等. **(meter 的复数形式是 metrics)**

在本系列博客里, 我会介绍如何将三个 Rust 服务通过 OpenTelemetry 生态, 将上述三个维度的数据上报的 SigNoz.

# FAQ:

Q: 什么是 OpenTelemetry?

A: OpenTelemetry (OTel) 是一个开源的可观测性标准, 它提供了:

1. 一套标准化的 API, 定义了 Trace, Log, Meter 的数据模型.
2. 一套标准化的各个语言的 SDK, 提供了 Trace, Log, Meter 的数据采集能力.
3. 一套标准化的 Collector, 规定了以什么样的通信协议和格式将数据上报到支持 OTel 的后端.

---

Q: 什么是 SigNoz?

A: SigNoz 是一个开源的可观测性平台, 它支持 OpenTelemetry 标准, 并且有个人觉得比较现代美观的 UI 可以查看数据. 当然最主要的原因是 DataDog 是付费的, SigNoz 是它的开源替代.

---

Q: 为什么三个服务都用 Rust?

A: 其实最开始我也写了一个 Node.js Fastify 服务, 但是 OTel 对于 Node.js 的支持实在是天坑. 简单来说, 它是通过劫持 `require` 方法, 给例如 `http`, `mongodb`, `redis` 等主流的库注入自己记录 trace 的代码, 但是我写的服务用的 ESM, 和 `require` 有不兼容的问题, 最后折腾了半天还是选择放弃, 选择全部用 Rust 来实现.

---

Q: 为什么有三个服务?

A: 服务 A 是 http 入口, 接收来自用户的请求. A 会通过 grpc 的方式调用服务 B, B 会通过 http 请求调用服务 C. 这样可以同时展示 grpc 和 http 这两种通信方式下如何分别将 trace 串起来.

---

# 前置知识

阅读本系列博客, 你需要对以下内容有了解:

- Rust
- axum + tonic
- Docker Compose

# 目标

1. 可以新建一个 Dashboard, 查看
