# 4. tracing 简介

[tracing](https://github.com/tokio-rs/tracing) 是一个 Rust 的生态里事实标准的 Instrumentation (插桩?) 库, 通常与 tracing_subscriber 一起使用. 前者定义了核心 API 来产生数据, 后者则定义了如何消费这些数据.

# tracing 核心概念

在使用 tracing 之前, 我们需要了解几个核心概念:

## 1. Span (跨度)

Span 代表了一个时间段, 它有开始时间, 也有结束时间.

举个例子, 当我们处理一个 HTTP 请求时, 从收到请求到返回响应, 这整个过程就可以看作是一个 Span. 在这个过程中, 我们可能会查询数据库, 这个查询过程也可以看作是一个子 Span.

所以 Span 是有层级关系的 (Tree 结构), 一个 Span 可以包含多个子 Span, 比如调用多个函数(串行并行都可以).

Span 可以映射为 OTel 里的 Trace.

## 2. Event (事件)

Tracing 里并没有日志 (log) 这个概念, 对应的概念其实是 Event. 比如 `info!()`, 文档里写的其实是 `Constructs an event at the info level.`, 日志只是一种对 Event 的注册消费而已.

Event 可以映射为 OTel 里的 Log.

## 3. Context (上下文)

这是 tracing 最强大的地方, 也是最容易让人困惑的地方.

## 显式传递 vs 隐式传递

在其他语言里 (比如 Go), 我们经常需要显式地把 `ctx` 作为第一个参数传给所有的函数:

```go
// Go style
func GetUser(ctx context.Context, id int) {
    // 必须手动把 ctx 传给 db query
    db.Query(ctx, ...)
}
```

这样做的好处是显而易见, 但坏处是污染了函数签名, 而且每一层都需要传递.

**在 Rust 的 tracing 里, Context 是隐式传递的.** 这意味着你不需要修改函数签名, 就可以在深层的函数里获取到上层的 trace 信息.

## 原理: Thread-Local

它是通过 **Thread-Local Storage (TLS)** 来实现的. `tracing` 在内部维护了一个 thread-local 的变量, 用来指向"当前正在执行的 Span".

当我们进入一个 Span 时, `tracing` 会把这个 Span 也就是 ID 推入一个 thread-local 的栈中. 当退出时, 再把它弹出.

```rust
// 伪代码: 同步代码中的原理
fn process_request() {
    let span = tracing::info_span!("request_handler");
    // _guard 是一个 RAII Guard.
    // 当由于 _guard 被创建, span 被"进入" (Enter), 也就是被推入 thread-local 栈.
    let _guard = span.enter();

    // 在这里面调用的任何函数, 如果尝试获取"当前 Span", 都会拿到 "request_handler"
    query_db();

    // 当函数结束, _guard 离开作用域被 Drop, span 被"退出" (Exit), 从栈中弹出.
}
```

## Async 的挑战

上面的模型在同步代码里工作得很完美. 但是在 Async Rust (Tokio) 里, 情况变复杂了.

**Future 是可以在线程间移动的.**

一个 `async fn` 可能会在 Thread A 上开始执行, 遇到 `.await` 挂起. 当 I/O 就绪后, Tokio 的 Runtime 可能会把它调度到 Thread B 上继续执行.

如果我们在 Thread A 上把 Span 存进了 Thread-Local, 那当这个 Future 跑到 Thread B 上时, Thread B 的 Local Storage 里并没有这个 Span!

### 解决方案: Instrumentation

这就是为什么我们需要 `#[instrument]`, 它的原理是把 Span "绑定" 到 Future 上.

当我们对一个 async function 使用 `#[instrument]` 时:

```rust
#[instrument]
async fn my_async_task() {
    // ...
}
```

它其实生成了类似这样的代码 (简化版):

```rust
// 这是一个 wrapper future
struct InstrumentedFuture {
    inner: InnerFuture,
    span: Span,
}

impl Future for InstrumentedFuture {
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // 1. 在 poll 之前, 这里的 span.enter() 会把 span ID 放到 当前线程 的 Thread-Local 里
        let _guard = self.span.enter();

        // 2. 执行真正的 poll (执行业务逻辑)
        let result = self.inner.poll(cx);

        // 3. poll 结束 (可能是 Ready 也可能是 Pending)
        // _guard 被 drop, span ID 从 当前线程 的 Thread-Local 里移除
        return result;
    }
}
```

每次 Future 被 poll 时, 它都会**临时**地把 Span 放到当前线程的 Thread-Local 里, 执行完那一小段逻辑后立刻移出. 这样无论 Future 被调度到哪个线程, 只要它在执行, `Thread-Local` 里就有正确的 Span 信息.

# Metrics 缺少映射

Tracing 里没有可以映射为 metrics 的概念, 所以需要单独使用 `opentelemetry` 相关 crate 来记录 metrics, 后面我们会介绍.

# tracing_subscriber

正如前面所说, `tracing` 库本身只是定义了一套 API (插桩), 它只负责"产生数据", 不负责"处理数据". 真正处理数据的是 **Subscriber**. 你可以把它想象成一个插座系统:

- `tracing` 就是插座面板, 你的代码往里面插点
- `Subscriber` 就是插在上面的电器 (比如风扇, 台灯).

我们可以有各种各样的 Subscriber:

- `tracing-subscriber::fmt`: 把数据打印到控制台 (stdout).
- `tracing-opentelemetry`: 把数据转换成 OpenTelemetry 格式, 然后发送给 Collector (比如 SigNoz).

在我们的 Demo 里, 我们会同时使用这两个 Subscriber: 既在控制台看日志, 又把 trace 发送到 SigNoz.

# 如何使用 Instrumentation

在 Rust 代码里使用 tracing 非常简单, 最常用的就是 `#[instrument]` 宏.

```rust
use tracing::{info, instrument};

#[instrument]
async fn get_user(id: u64) {
    info!("Starting to get user..."); // 这是一个 Event
    // ... 业务逻辑
}
```

当你给一个函数加上 `#[instrument]` 之后:

1. 每次调用这个函数, 都会自动创建一个 Span.
2. 函数的参数 (比如 `id`) 会自动作为 Span 的属性 (Attribute) 被记录下来.
3. 当函数结束时, Span 会自动结束.

是不是很方便? 根本不需要手动创建 Span, start, end. 在接下来的代码实战中, 你会看到我们大量使用这个宏.

# 流程图

![tracing 流程](https://github.com/Arichy/blogs/blob/main/docs/Rust/Observability-With-OpenTelemetry-And-SigNoz/imgs/4-1.png?raw=true)

当一个新的 Span 产生, 会经过所有注册过的 layer, 然后存到 registry 里的一个 span pool 中, 挂到当前 span 下作为子 span.

当一个 Event 产生, 比如调用 `info!("hello")`, 它会经过 `tracing_subscriber` 注册过的所有 layer, 最后被释放. 在经过 layer 时, 可以查询自己处于哪个 span 中.
