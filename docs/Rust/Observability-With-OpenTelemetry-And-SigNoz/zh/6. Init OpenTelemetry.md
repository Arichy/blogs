# 6. Init OpenTelemetry

# 相关 crates 简介

接下来我们开始在三个服务中集成 OpenTelemetry. 首先打个预防针, OpenTelemetry 是目前我见过的所有生态里面最混乱的一个, 你可以看看 `Cargo.toml`:

```toml
opentelemetry = { version = "0.31.0", features = ["trace", "metrics", "logs"] }
opentelemetry-otlp = { version = "0.31.0", features = [
  "grpc-tonic",
  "trace",
  "metrics",
  "logs",
] }
opentelemetry_sdk = { version = "0.31.0", features = [
  "rt-tokio",
  "trace",
  "metrics",
  "logs",
] }
opentelemetry-appender-tracing = { version = "0.31.1", features = [
  "experimental_metadata_attributes",
] }
tracing-opentelemetry = "0.32.1"
opentelemetry-http = "0.31.0"
opentelemetry-semantic-conventions = { version = "0.31.0", features = [
  "semconv_experimental",
] }
```

但凡是个正常人看到这一堆头都大了. 我来尝试逐个解释一下:

1. **`opentelemetry`**:
   这是 OTel 的核心 API 定义. 它只定义了 Trait 和数据结构 (比如 `Tracer`, `Meter`, `Span`), 不包含具体的实现. 就像 `tracing` crate 一样.

2. **`opentelemetry_sdk`**:
   这是 OTel 的官方 SDK 实现. 它负责真正地创建 Span, 采样 (Sampling), 批处理 (Batching), 以及导出 (Export). 如果你只引用 `opentelemetry` 而不引用 sdk, 那么什么都不会发生.

3. **`opentelemetry-otlp`**:
   OTel 支持多种导出协议 (比如 Zipkin, Jaeger, Prometheus). OTLP (OpenTelemetry Protocol) 是 OTel 原生推荐的传输协议. 这个 crate 包含了一个 Exporter, 它能把 SDK 产生的数据打包成 OTLP 格式 (通常是通过 gRPC 或 HTTP) 发送给 Collector (SigNoz).
   - 注意不要混淆了 otlp 的 gRPC / HTTP 与我们 demo 里几个服务之间的 gRPC/ HTTP, 前者是 OTel 的传输协议, 后者是我们的业务服务之间的通信协议.
   - 注意 `grpc-tonic` feature: 我们使用 gRPC 发送数据.

4. **`tracing-opentelemetry`**:
   这是连接 `tracing` 生态和 `OpenTelemetry` 生态的桥梁. 还记得我们前面说的 `Subscriber` 吗? 这个 crate 提供了一个 `OpenTelemetryLayer`, 它可以订阅 `tracing` 产生的 `Span`, 然后把它们转换成 `OpenTelemetry` 的 `Span`, 最后交给 `opentelemetry_sdk` 处理. **这是最关键的粘合剂.**

5. **`opentelemetry-appender-tracing`**:
   这也是一个桥梁, 但是是为了 **Log (日志)**. OpenTelemetry 也有自己的 Log API. 这个 crate 允许把 `tracing` 产生的日志 (Event) 转换成 OpenTelemetry 的 LogRecord, 然后发送出去.

6. **`opentelemetry-http`**:
   提供了一些 HTTP 相关的工具, 主要是为了 Context Propagation (上下文传播). 比如把 trace-id 注入到 HTTP Header 里.

7. **`opentelemetry-semantic-conventions`**:
   定义了一些标准化的属性名称 (常量). 比如 `http.method`, `db.system` 等. 避免大家随手乱起名, 导致后端虽然收到了数据但是没法统一展示.

# Init tracer

由于 `service_name` 是需要被 tracing/metrics/logs 共享的, 所以我们用一个全局变量来保存它.

```rust
use opentelemetry_sdk::Resource;

fn get_resource(service_name: &str) -> Resource {
    use std::sync::OnceLock;
    static RESOURCE: OnceLock<Resource> = OnceLock::new();
    RESOURCE
        .get_or_init(|| {
            Resource::builder()
                .with_service_name(service_name.to_string())
                .build()
        })
        .clone()
}
```

然后开始初始化 tracer

```rust
use opentelemetry::global;
use opentelemetry_otlp::SpanExporter; // 来自 opentelemetry_otlp, 这个是负责具体上报的 otlp 协议的. SpanExporter 的作用是把 tracing data 发送给 collector
use opentelemetry_sdk::trace::SdkTracerProvider;

fn init_tracer(endpoint: &str, service_name: &str) -> Result<SdkTracerProvider, anyhow::Error> {
    // 1. 先创建一个 span exporter
    let exporter = SpanExporter::builder()
        .with_tonic() // 使用 grpc 上报
        .with_endpoint(endpoint) // "http://localhost:4317" 是 SigNoz 的默认端口
        .build()?;

    // 2. 创建 tracer provider
    let provider = SdkTracerProvider::builder()
        .with_resource(get_resource(service_name)),
        .with_batch_exporter(exporter)
        .build();

    Ok(provider)
}
```

# Init logs

```rust
use opentelemetry_sdk::logs::SdkLoggerProvider;
use opentelemetry_otlp::LogExporter;

fn init_logs(endpoint: &str, service_name: &str) -> Result<SdkLoggerProvider, anyhow::Error> {
    // 1. 创建一个 log exporter
    let exporter = LogExporter::builder()
        .with_tonic()
        .with_endpoint(endpoint)
        .build()?;

    // 2. 创建 logger provider
    let provider = SdkLoggerProvider::builder()
        .with_resource(get_resource(service_name))
        .with_batch_exporter(exporter)
        .build();

    Ok(provider)
}
```

# Init metrics

```rust
use opentelemetry_sdk::metrics::{PeriodicReader, SdkMeterProvider},
use opentelemetry_otlp::MetricExporter;

fn init_metrics(endpoint: &str, service_name: &str) -> Result<SdkMeterProvider, anyhow::Error> {
    // 1. 创建一个 metric export
    let exporter = MetricExporter::builder()
        .with_tonic()
        .with_endpoint(endpoint)
        .build()?;

    // 2. 创建一个 periodic reader, 每隔 10 秒上报一次, (生产环境一般不会这么频繁, 只是为了演示方便设定 10 秒)
    let reader = PeriodicReader::builder(exporter)
        .with_interval(Duration::from_secs(10))
        .build();

    // 3. 创建 meter provider
    let provider = SdkMeterProvider::builder()
        .with_resource(get_resource(service_name))
        .with_reader(reader)
        .build();

    global::set_meter_provider(provider.clone()); // 设置全局 meter provider, 前文提到 tracing 里没有对应 metrics 的概念, 所以需要用 OTel 自己的 metrics 那一套方案

    Ok(provider)
}
```
